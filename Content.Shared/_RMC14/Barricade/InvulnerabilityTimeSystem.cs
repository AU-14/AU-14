using Content.Shared.Interaction.Events;
using Content.Shared.Weapons.Melee.Events;
using Content.Shared.Effects;
using Content.Shared.Whitelist;
using Robust.Shared.Timing;
using Robust.Shared.Network;
using Robust.Shared.Player;

namespace Content.Shared._RMC14.Barricade;

public sealed class InvulnerabilityTimeSystem : EntitySystem
{
    [Dependency] EntityWhitelistSystem _whitelist = default!;
    [Dependency] IGameTiming _timing = default!;
    [Dependency] private readonly INetManager _net = default!;
    [Dependency] private readonly SharedColorFlashEffectSystem _colorFlash = default!;
    public override void Initialize()
    {
        base.Initialize();

        SubscribeLocalEvent<InvulnerabilityTimeComponent, AttackedEvent>(OnAttack);
        SubscribeLocalEvent<InvulnerabilityTimeComponent, GettingAttackedAttemptEvent>(OnAttackAttempt);
    }

    private void OnAttack(Entity<InvulnerabilityTimeComponent> ent, ref AttackedEvent args)
    {
//        if (_net.IsClient)
//           return;

        if (_whitelist.IsWhitelistPass(ent.Comp.Whitelist, args.User) && _whitelist.IsBlacklistFailOrNull(ent.Comp.Blacklist, args.User))
        {
            if (ent.Comp.CurrentHits == 0)
            {
                ent.Comp.WearOffTime = _timing.CurTime + ent.Comp.InvulnerabilityTime;
            }

            ent.Comp.CurrentHits++;
            Dirty(ent, ent.Comp);
        }
    }

    private void OnAttackAttempt(Entity<InvulnerabilityTimeComponent> ent, ref GettingAttackedAttemptEvent args)
    {
        if (_whitelist.IsWhitelistPass(ent.Comp.Whitelist, args.Attacker) && _whitelist.IsBlacklistFailOrNull(ent.Comp.Blacklist, args.Attacker))
        {
            if (ent.Comp.CurrentHits >= ent.Comp.HitsToInvulnerability)
            {
                args.Cancelled = true;
                if(_net.IsClient)
                    _colorFlash.RaiseEffect(Color.Yellow, new List<EntityUid> { ent }, Filter.PvsExcept(ent));
            }
        }
    }

    public override void Update(float frameTime)
    {
        if (_net.IsClient)
            return;

        var time = _timing.CurTime;
        var query = EntityQueryEnumerator<InvulnerabilityTimeComponent>();

        while(query.MoveNext(out var uid, out var timeComp))
        {
            if (timeComp.CurrentHits > 0 && time >= timeComp.WearOffTime)
            {
                timeComp.CurrentHits = 0;
                Dirty(uid, timeComp);
            }
        }
    }
}
